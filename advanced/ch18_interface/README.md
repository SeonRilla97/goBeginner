# Go의 인터페이스

추상화를 통해 비즈니스 로직이 구체화된 객체에 의존하지 않도록 하기 위함


### 덕 타이핑

"오리처럼 걷고 오리처럼 행동하면 오리 아님??"

-->인터페이스의 메소드를 타입이 구현만 하면, 명시적 선언 없이도
이는 인터페이스를 구현한것이다. (판단은 컴파일러가!)

-->  타입 선언 시 인터페이스 구현 여부를 명시적으로 나타낼 필요 없이 인터페이스에 정의한 메서드 포함 여부만으로 결정하는 방식


얻는 이점?
```
   1. "미리 계획하지 않아도, 나중에 필요할 때 기존 코드들을 새로운 추상화에 끼워맞출 수 있다"
   2. 기능 제공자가 아닌 패키지를 이용하는 쪽에서 인터페이스를 만든다.
```

이점 정리
```
   1. 외부 라이브러리 바로 활용
   2. 점진적 리팩토링
   3. 테스트 용이성
   4. 보일러플레이트 코드 제거
   5. 레거시 시스템과의 호환성
```


### 인터페이스의 사용

1. 인터페이스에 인터페이스를 포함
2. 빈 인터페이스 <- 함수, 메서드, 변수 다 받을 수 있음
3. 인터페이스의 기본값은 nil <- 반드시 nil 확인 구문 필요(런타임 에러 남)
4. 인터페이스 타입 변환 [[ 인터페이스변수.(타입)]]
   - 타입 변환 불가능하다면 컴파일 에러
   - 타입 변환에 실패할 시 런타임 에러
   - 인터페이스 변환 시 변환 여부를 반드시 확인
```go
c, ok := reader.(Closer) // 변환값, 성공여부
if ok{
	c.Close()
}

=======

if c, ok := reader.(Closer); ok{
}
```